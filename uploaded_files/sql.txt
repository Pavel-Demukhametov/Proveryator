Привет, я Андрей Сазыкин, это курс «Основы SQL», тема лекции «Сортировка в SQL с помощью ключевого слова Odebuy». В SQL для извлечения данных мы используем оператор Select, однако в Select данные могут быть извлечены в любом порядке. Нет никакой гарантии, в каком порядке строки будут извлечены из таблицы. Не обязательно порядок будет точно такой же, который вы использовали при вставке или какой-то другой. Более того, если вы несколько раз запустите оператор Select, есть вероятность, что данные будут в разном порядке. На практике такое встречается редко, но теоретически это возможно. Если вы хотите, чтобы извлеченные данные выдавались в определенном порядке, для этого нужно использовать сортировку. В SQL сортировка задается с помощью ключевого слова odeby. odeby записывается после ключевого слова from. Здесь Здесь в примере мы извлекаем все данные из таблицы супергероев и сортируем их по столбцу Е. Напомню, что в этом столбце, в таблице супергероев, хранится год, в котором супергерой первый раз появился в комиксах. Вот результат выполнения запроса. Данные из таблицы супергероев отсортированы по столбцу Е. Сначала идет информация о супергероях, которые появились раньше всех в 1936 году. Потом те супергерои, которые появились в следующем, в 1937 году. Потом супергерои, которые появились в 1938 году и так далее. Сортировать данные можно по любому столбцу таблиц. В SQL используются два порядка сортировки. По умолчанию применяется сортировка по возрастанию. Ascending order. Порядок сортировки мы можем явно указывать в ключевом слове ODE BY. Если мы напишем ASK, будет использоваться сортировка по умолчанию, а DESK, сокращение ADDESCENDING ODE, сортировка по убыванию. Например, если мы хотим отсортировать героев по популярности и начать с тех, кто наиболее популярным, то нам необходимо отсортировать данные в таблице супергероев по столбцу appearances напомню что в этом столбце содержится количество появлений супергероев в комиксах при этом мы указываем ключевое слово desk будем использовать сортировку по убыванию на первой позиции будет герой который появлялся в комиксе больше всего, а после этого будут идти менее популярные супергерои. Вот результат выполнения запроса. На первой позиции Spider-Man, Человек-паук. Он появлялся в комиксах 4043 раза, это больше, чем другие герои. Напомню, что это данные на 2014 год и сейчас вполне могли измениться. На втором месте Капитан Америка. Количество появлений в комиксах 3360, затем Бэтмен 3093. И дальше идут остальные супергерои, которые встречаются в комиксах реже. В операторе Select можно использовать одновременно сортировку и фильтры. Например, если мы хотим показать самых популярных отрицательных супергероев, то сначала мы используем ключевое слово WHERE. Чтобы задать фильтр, столбец ALIGN должен равняться bad character, плохой персонаж или отрицательный персонаж. С помощью этого мы выберем отрицательных супергероев. А после этого результаты нужно отсортировать по столбцу appearances, order by appearances, в порядке убывания. Ключевое слово – desk. Вот результаты. Мы видим, что показаны только отрицательные супергерои. Значение столбца Align содержит better characters. И герои, отсортированные в порядке убывания популярности. Самый первый супергерой, Виктор фон Дум, встречается в комиксах 721 раз. Второй супергерой 692 раза. И остальные встречаются реже. Также мы можем ограничивать количество данных которые будут выводиться с помощью оператора select и сортировки я надеюсь вы помните что для этого используется ключевое слово limit например если мы хотим вывести топ 5 супергероинь злодеек то для этого можем использоваться вот таким запросом сначала мы использ where для того, чтобы отфильтровать супергероинь злодеек. Здесь у нас сложный запрос, состоящий из двух условий, которые должны выполняться одновременно. Оператор end. Первое условие супергерою должен быть отрицательным. Align равняется bad characters. И второе, нам нужны супергерои женщины. Gender равняется Bad Characters. И второе. Нам нужны супергерои-женщины. Gender равняется Female Characters. Отфильтрованных таким образом супергероев мы сортируем по популярности, порядке убывания, Order by Appearances, Desk. И после этого оставляем только 5 наиболее популярных супергероев. Limit 5. Вот результат выполнения. Всего популярных супергероев. Лимит 5. Вот результат выполнения. Всего лишь 5 супергероев. Все они отрицательные. Все они женщины. И отсортированы в порядке убывания популярности. Сортировку также можно выполнять не по одному, а по нескольким столбцам. Например, если мы выполним сортировку по двум столбцам «Е» и «Appearances», в этом случае столбцы после «other by» записываются друг за другом через запятую, то получим следующий результат. Сначала супергерои отсортированы по году появления, а внутри каждого года по количеству появлений в порядке возрастания. Так как здесь мы не указывали порядок сортировки, то по умолчанию используется именно сортировка по возрастанию. Сначала идут три супергероя, появившиеся в 1936 году. Первый супергерой, точнее супергероиня, появлялась 13 раз, второй супергерой 41, третий супергерой 92 раза. Затем супергерои, появившиеся в 1937 году, они также отсортированы внутри года в порядке возрастания. Первая героиня появлялась 11 раз, второй герой 79, третий 213. После этого идут герои, появившиеся в 1938 году, также отсортированы в порядке популярности по возрастанию и так далее. Надеюсь, вы уже обратили внимание, что синтаксис SQL достаточно простой. При этом он похож на английский язык. Запросы SQL составляются почти так же, как мы бы говорили на английском языке. Например, запрос, который позволяет получить топ-5 супергероинь-злодеек, выглядит следующим образом. Select «Извлечь все» из таблицы супергероев, from superheroes, где align равняется bet characters and gender равняется female characters. Перечисляем условия. Order by Appearances Desk. Отсортируй в порядке убывания по количеству появлений. Limit 5. Ограничь результаты пятью строками. Напомню, что первоначально SQL назывался SQL. Structured English Query Language. Структурированный английский язык запросов. И хотя почти сразу после разработки языка SQL английский убрали из его названия, но логика работы осталась. Поэтому запросы SQL достаточно просто понять, даже если вы не знаете тот или иной элемент синтаксиса. Если вы знаете английский, то с очень высокой долей вероятности поймете что имеется в виду но с другой стороны в этом же заключается и сложность SQL из достаточно простых конструкций такие как select from where order by limit и других ключевых слов которые мы с вами рассмотрим в следующих лекциях можно строить достаточно сложные конструкции. Так же как с помощью английских или русских слов и конструкций можно строить большие и громоздкие предложения, которые будут очень плохо понятны. Итак, в этой лекции мы рассмотрели, как в SQL выполнять сортировку. Это делается с помощью ключевого слова ODEBUY. Сортировать данные мы можем по одному или нескольким столбцам. При этом, если не указать ODEBUY, то мы не можем делать никаких предположений о том, в каком порядке строки будут извлечены из таблицы. Порядок сортировки может быть возрастающий – ascending – ключевое слово ASK, или убывающий – descending – ключевое слово Ask, или убывающий – Descending – ключевое слово Desk. Если вы не укажете порядок сортировки, то по умолчанию будет использоваться сортировка по возрастанию. В Select и других операторах SQL можно использовать одновременно несколько ключевых слов, которые идут друг за другом. Мы рассмотрели, как в Select использовать совместно WHERE для фильтрации данных, ODEBAY для сортировки отфильтрованных данных и LIMIT для ограничения количества выводимых строк. И мы рассмотрели, что SQL по структуре очень похож на английский. Поэтому, если вы пока не знаете все ключевые слова SQL, но знаете английский, то с очень высокой вероятностью вы поймете, что делает тот или иной запрос. Надеюсь, это поможет вам выучить SQL проще. А на этом лекция закончена. 
 добрый день мои маленькие любители программирования у нас начинается следующее занятие вот я создал новый блокнот обозвал его задание номер три и сегодня мы займемся такими вещами как группировка сортировка и корреляция. Что я сделал в самом начале? Как обычно, я скопипастил текст из предыдущих блокнотов, в котором мы подключаем библиотеку Pandas, загружаем данные из файла и выводим информацию о таблице на экран. Информацию о таблице мы выводим на экран, потому что это очень удобно. Знать, какие у нас столбцы, как они называются, потому что мы к ним будем обращаться. Поехали дальше. Далее. Нам понадобится более простая таблица, которая состоит из не всех 48 столбцов, а только из 3. Чтобы получить таблицу, в которой входят не все столбцы, а только избранные, нужно вызвать соответствующую команду. На одном из предыдущих занятий я объяснял смысл вот этой всей конструкции. Квадратные скобки это, грубо говоря, сокращение фразы «те, которые». Так вот, вы должны взять исходную таблицу по имени df и в ней взять столбцы, те, которые принадлежат вот этому списку. И все эти столбцы мы копируем в новую таблицу, которая называется df-cat, то есть обрезанная df. И вот после этого можно заголовок этой новой таблицы вывести на печать. Она будет выглядеть примерно так. Понятное дело, что в ней столько же объектов, порядка 186, но столбцов всего три. Те, которые мы вот указали. И вот как раз давайте эту таблицу будем сортировать. А именно, давайте рассмотрим, что будет происходить при сортировке значений в этой таблице. Итак. Сделаем под заголовочек сортировка. Хорошо. Вы, наверное, сейчас ожидаете, что я сейчас подгляжу в шпаргалку и вам выкачу, как называется функция, которая вызывает сортировку. Ну и вообще ожидаете, что я ваментацию, информацию по тем функциям, которые они хотят вызывать. Собственно, гугление это то постыдное действие, которое айтишники регулярно делают на рабочем месте, но стыдятся в этом признаться. Так вот, давайте сейчас мы на 5 минут станем настоящими айтишниками и полезем за помощью в Google. Потому что, сами понимаете, я же не могу до всю жизни, так сказать, вас снабжать очищенной рафинированной информацией. Давайте полезем в интернет и посмотрим, в каком виде информация там представлена. Итак, первым делом вам нужно определиться, что вы будете искать в Google. Ну, очевидно, мы будем искать, как сортируются данные в Python. А точнее, нужно конкретизировать ваш запрос. Вас интересует сортировка в Pandas. Pandas это вот та самая библиотека, в которой работают таблицы. Потому что если вы в запросе не упомянете ключевое слово Pandas, то, скорее всего, вам выдадут источники на то, как вообще можно сортировать данные, которые не обязательно представлены в виде таблицы. А вас интересуют именно таблицы. Поэтому обязательно нужно написать ключевое слово сортировка и ключевое слово pandas. Я это уже сделал, чтобы не тратить время, и вот он мне выдал соответствующую выдачу страниц. Ну, давайте лезем в самый первый источник. Как правило, Google в качестве первого источника выдает самый релевантный, потому что все-таки Google, он достаточно умная машина. Так, вот тут есть некоторая статья, она на русском языке, то есть вы можете ее прекрасно прочитать. Значит, я это, конечно, все опускаю. Кому интересно, надо читать очень внимательно. Ну вот я мотаю, мотаю, мотаю, и нам интересна вот сортировка по одному столбцу. Читаем. Чтобы отсортировать DataFrame, ну то есть таблицу, по одному столбцу, вот, надо указать его имя и порядок сортировки. С помощью вот параметра Ascending. А также вот с помощью ключевого слова Buy вы задаете тот столбец, относительно которого вы будете сортировать. Так, это даже все можно скопировать к себе в блокнот, чтобы не постоянно бегать между вкладками. Понятное дело, что сейчас, если вы запустите, то произойдет ошибка, потому что вот этот вот столбец лайки, он относился к тому датафрейму, который был на веб-странице, к датафрейму из примера. У вас, естественно, такого столбца нет. Вам нужно определиться, как мы будем сортировать. Ну давайте, допустимим по возрасту и еще важный момент ваша таблица она имеет название dfк от то есть видите мы же с ней сейчас работаем вот она вот поэтому надо не забыть указать именно ее запускаем по возрасту обратите внимание на вот этот самый параметр ascending он задает тип сортировки по убыванию либо по возрастанию но давайте возьмем и сравним запустим все то же самое только вот здесь параметр будет true true то есть истина то есть возрастающие а вот тут сортировка была по убыванию и действительно начиная от самого старого и кончая самым молодым а вот здесь все будет наоборот запускаем смотрим действительно начиная от самого молодого и кончая самым возрастным что еще можно узнать про сортировку вот в этой вот веб странице так вот читаем следующий параграф сортировка по нескольким столбцам в чем ее смысл смотрите допустим мы хотим людей отсортировать по возрасту, а тех людей, у которых возраст одинаков, будем, допустим, сортировать по росту. Поэтому возникает очень сложная процедура сортировки. Сначала сортируется возраст, а в случае совпадения возраста сортируется рост. Ну давайте посмотрим, как это делается. Вот если вы внимательно прочитаете этот пример на вашей веб-странице, то поймете, какие параметры, что значит. Во-первых, заменяем название таблицы. Во-вторых, вот это все тоже нужно похерить, потому что у нас названия столбцов свои, другие. Ну и давайте вот тут вот возьмем, не забывайте про кавычки, в которые вы засовываете название столбца. И вот так вот. Ну давайте запустим. Итак, что мы знаем? Поскольку сначала сортируется по возрасту и порядок возрастания по убыванию. А в случае совпадения возраста сортируем по росту в порядке убывания. Смотрим, что получается. Ну, по возрасту мы видим, что картина та же самая, что и в предыдущих, так сказать, распечатках таблицы. Действительно, по возрасту мы отсортировали по убыванию. А теперь смотрите. А в случае, если возраст совпадает, как, допустим, у вот этих вот трех людей, в бой вступает сортировка по росту. И эти люди, у которых возраст одинаковый сортируется по росту, тоже в порядке убывания. Видите, вот тоже порядок убывания. Вот с этими параметрами можно, конечно же, поиграться. Например, по росту можно сортировать, например, в порядке возрастания. Видите? Вот есть люди, у которых одинаковый возраст, но теперь уже порядок упорядочения по росту другой, от меньшего к большему. Разумеется, если мы вот тут поменяем на true, а вот тут на false, то много чего изменится. Во-первых, сортировка будет по увеличению возраста. А у людей, у которых возраст одинаковый, рост будет сортироваться от большего вот как здесь к меньшему. Вот как здесь. Разумеется. Давайте тут поставлю false и мы вернемся к самой моей первой версии сортировки когда и возраст и рост сортируются по убыванию а вот представьте и вот тут переставлю их местами. Что произойдет? В школе вы привыкли, что от перемены мест слагаемых сумма не меняется, но вот тут на самом деле может поменяться очень многое, потому что теперь мы требуем, что вначале идет сортировка по росту и только потом уже по возрасту. Это принципиально другая сортировка, принципиально другая операция. Запускаем. И что мы видим? Мы видим, что вначале алгоритм смотрит на рост. Поэтому вначале у нас выйдет человек с самым большим ростом. Ну и так далее. Видите, далее, далее, далее рост уменьшается. А на возраст теперь мы смотрим только в том случае, когда рост уменьшается а на возраст теперь мы смотрим только в том случае когда рост у наших людей одинаковый вот как это происходит например вот здесь у этих людей рост одинаковый 188 но поскольку по возрасту задана сортировка тоже по убыванию вперед идет человек у которого возраст больший вот такие вот дела